package main

import (
	"bytes"
	"context"
	"embed"
	"flag"
	"fmt"
	"log"
	"os"
	"reflect"
	"regexp"
	"sort"
	"strings"
	"text/template"

	"github.com/hashicorp/go-multierror"

	"cdr.dev/slog"
	"cdr.dev/slog/sloggers/sloghuman"

	"github.com/coder/coder/coderd/database"
	"github.com/coder/coder/coderd/rbac"
)

var (
	GetMethodRegex = regexp.MustCompile(`^Get(\w+)$`)

	contextType    = reflect.TypeOf(new(context.Context)).Elem()
	errorType      = reflect.TypeOf(new(error)).Elem()
	rbacObjectType = reflect.TypeOf(new(rbac.Objecter)).Elem()
	dbStoreType    = reflect.TypeOf(new(database.Store)).Elem()

	//go:embed templates/*
	templates embed.FS
)

func main() {
	ignoreExisting := flag.Bool("ignore-existing", false, "ignore existing methods on AuthzQuerier")
	packageName := flag.String("package", "database", "package name for generated file")

	flag.Parse()

	skip := make(map[string]bool)
	if !*ignoreExisting {
		skip = existingMethods()
	}

	ctx := context.Background()
	log := slog.Make(sloghuman.Sink(os.Stderr))
	output, err := Generate(*packageName, skip)
	if err != nil {
		log.Fatal(ctx, err.Error())
	}

	// Just cat the output to a file to capture it
	fmt.Println(output)
}

func existingMethods() map[string]bool {
	existing := make(map[string]bool)
	authzQuerier := reflect.TypeOf(database.AuthzQuerier{})
	for i := 0; i < authzQuerier.NumMethod(); i++ {
		existing[authzQuerier.Method(i).Name] = true
	}
	return existing
}

func Generate(packageName string, skip map[string]bool) (string, error) {
	tpls, err := template.ParseFS(templates, "templates/*.tmpl")
	if err != nil {
		log.Fatalf("failed to parse templates: %v", err)
	}
	methods := storeMethods()

	generate := make([]ParsedMethod, 0)
	for _, method := range methods {
		if method == nil {
			// TODO: None of the methods should be nil
			continue
		}
		if _, ok := skip[method.Name()]; ok {
			continue
		}
		generate = append(generate, method)
	}

	// Sort for consistent output
	sort.Slice(generate, func(i, j int) bool {
		return generate[i].Name() < generate[j].Name()
	})

	var output bytes.Buffer
	// Write the header of the new file.
	output.WriteString("// Code generated by authzmethods; DO NOT EDIT.\n")
	output.WriteString("// Functions generated in this file will not conflict with\n")
	output.WriteString("// methods in database/authzmethods.go. If you believe there is\n")
	output.WriteString("// an error in a method, write it manually there and regenerate this file.\n")
	output.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	sep := "\n\n"
	var merr error
	for _, v := range generate {
		out, err := v.Generate(tpls)
		if err != nil {
			// Collect all errors and return them at the end
			merr = multierror.Append(merr, err)
			continue
		}
		out = strings.TrimSpace(out)
		// empty line between each function
	}

	return output.String(), merr
}

type ParsedMethod interface {
	Name() string
	Generate(tpl *template.Template) (string, error)
}

// GetMethod is any method with 2 arguments as input and 2 outputs.
// These methods are used when the rbac object comes from the database
// and the rbac object permission can be checked after a fetch.
// The function name must begin with "Get"
//
// Arguments:
// 1. context.Context
// 2. any
// Outputs:
// 1. rbac.Objecter
// 2. error
//
// GetMethods should not result in any database mutations.
// Note: @Emyrk we could look at the sql statements to see if any 'Update', 'Insert',
// or other mutations are being performed with a string search.
type GetMethod struct {
	Raw          reflect.Method
	FunctionName string
	ArgumentType string
	ReturnType   string
}

func (m GetMethod) Name() string { return m.Raw.Name }
func (m GetMethod) Generate(tpl *template.Template) (string, error) {
	var buf bytes.Buffer
	err := tpl.Lookup("get_method").Execute(&buf, m)
	return buf.String(), err
}

func storeMethods() []ParsedMethod {
	methods := make([]ParsedMethod, 0)
	for i := 0; i < dbStoreType.NumMethod(); i++ {
		method := dbStoreType.Method(i)
		methods = append(methods, parseMethod(method))
	}
	return methods
}

func parseMethod(method reflect.Method) ParsedMethod {
	if getMethod, ok := parseGetMethod(method); ok {
		return getMethod
	}

	return nil
}

func parseGetMethod(method reflect.Method) (GetMethod, bool) {
	// Match the method name.
	if !GetMethodRegex.MatchString(method.Name) {
		return GetMethod{}, false
	}

	// Requires 2 inputs, 2 outputs.
	if method.Type.NumIn() != 2 || method.Type.NumOut() != 2 {
		return GetMethod{}, false
	}

	if method.Type.In(0) != contextType {
		return GetMethod{}, false
	}

	if !method.Type.Out(0).Implements(rbacObjectType) {
		return GetMethod{}, false
	}

	if method.Type.Out(1) != errorType {
		return GetMethod{}, false
	}

	return GetMethod{
		Raw:          method,
		FunctionName: method.Name,
		ArgumentType: method.Type.In(1).String(),
		ReturnType:   method.Type.Out(0).String(),
	}, true
}
