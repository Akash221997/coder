package main

import (
	"bytes"
	"context"
	"embed"
	"flag"
	"fmt"
	"log"
	"os"
	"reflect"
	"regexp"
	"sort"
	"strings"
	"text/template"

	"github.com/hashicorp/go-multierror"

	"cdr.dev/slog"
	"cdr.dev/slog/sloggers/sloghuman"
	"github.com/coder/coder/coderd/database"
	"github.com/coder/coder/coderd/rbac"
)

var (
	GetMethodRegex = regexp.MustCompile(`^Get(\w+)$`)

	contextType    = reflect.TypeOf(new(context.Context)).Elem()
	errorType      = reflect.TypeOf(new(error)).Elem()
	rbacObjectType = reflect.TypeOf(new(rbac.Objecter)).Elem()
	dbStoreType    = reflect.TypeOf(new(database.Store)).Elem()

	//go:embed templates/*
	templates embed.FS
)

func main() {
	ignoreExisting := flag.Bool("ignore-existing", false, "ignore existing methods on AuthzQuerier")
	packageName := flag.String("package", "database", "package name for generated file")

	flag.Parse()

	skip := make(map[string]bool)
	if !*ignoreExisting {
		skip = existingMethods()
	}

	ctx := context.Background()
	log := slog.Make(sloghuman.Sink(os.Stderr))
	output, err := Generate(*packageName, skip)
	if err != nil {
		log.Fatal(ctx, err.Error())
	}

	// Just cat the output to a file to capture it
	fmt.Println(output)
}

func existingMethods() map[string]bool {
	existing := make(map[string]bool)
	authzQuerier := reflect.TypeOf(database.AuthzQuerier{})
	for i := 0; i < authzQuerier.NumMethod(); i++ {
		existing[authzQuerier.Method(i).Name] = true
	}
	return existing
}

func Generate(packageName string, skip map[string]bool) (string, error) {
	tpls, err := template.ParseFS(templates, "templates/*.tmpl")
	if err != nil {
		log.Fatalf("failed to parse templates: %v", err)
	}
	parsed := generateStoreMethods(skip)

	generate := make([]*ParsedMethod, 0)
	for _, method := range parsed.Methods {
		if method == nil {
			// TODO: None of the methods should be nil
			continue
		}
		generate = append(generate, method)
	}

	// Sort for consistent output
	sort.Slice(generate, func(i, j int) bool {
		return generate[i].Name < generate[j].Name
	})

	var output bytes.Buffer
	// Write the header of the new file.
	output.WriteString("// Code generated by authzmethods; DO NOT EDIT.\n")
	output.WriteString("// Functions generated in this file will not conflict with\n")
	output.WriteString("// methods in database/authzmethods.go. If you believe there is\n")
	output.WriteString("// an error in a method, write it manually there and regenerate this file.\n")
	output.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	// Write the imports
	output.WriteString("import (\n")
	for _, imp := range parsed.RequiredImports {
		output.WriteString(fmt.Sprintf("\t %q\n", imp))
	}
	output.WriteString(")\n\n")

	sep := ""
	var merr error
	for _, v := range generate {
		out, err := v.Generate(tpls)
		if err != nil {
			// Collect all errors and return them at the end
			merr = multierror.Append(merr, err)
			continue
		}
		out = strings.TrimSpace(out)
		// empty line between each function
		output.WriteString(sep + out)
		sep = "\n\n"
	}

	return output.String(), merr
}

type ParsedMethod struct {
	Name          string
	Raw           reflect.Method
	RequiredTypes []reflect.Type
	TemplateName  string
	TemplateData  any
}

func (m ParsedMethod) Generate(tpl *template.Template) (string, error) {
	var buf bytes.Buffer
	err := tpl.Lookup("get_method").Execute(&buf, m)
	return buf.String(), err
}

type Parsed struct {
	Methods         []*ParsedMethod
	RequiredImports []string
}

func generateStoreMethods(skip map[string]bool) Parsed {
	requiredImports := make(map[string]bool)
	methods := make([]*ParsedMethod, 0)
	for i := 0; i < dbStoreType.NumMethod(); i++ {
		method := dbStoreType.Method(i)
		if _, ok := skip[method.Name]; ok {
			continue
		}

		parsed := parseMethod(method)
		if parsed != nil {
			methods = append(methods, parsed)
		}
	}

	imported := make(map[string]bool)
	imports := make([]string, 0, len(requiredImports))
	for _, method := range methods {
		for _, t := range method.RequiredTypes {
			if !localType(t) && t.PkgPath() != "" {
				if _, ok := imported[t.PkgPath()]; ok {
					continue
				}
				imported[t.PkgPath()] = true
				imports = append(imports, t.PkgPath())
			}
		}
	}
	// TODO: Sort imports better
	sort.Strings(imports)

	return Parsed{
		Methods:         methods,
		RequiredImports: imports,
	}
}

func parseMethod(method reflect.Method) *ParsedMethod {
	if getMethod, ok := parseGetMethod(method); ok {
		return getMethod
	}

	return nil
}

type getMethodData struct {
	FunctionName string
	ArgumentType string
	ReturnType   string
}

// parseGetMethod returns a basic GetMethod.
// GetMethod is any method with 2 arguments as input and 2 outputs.
// These methods are used when the rbac object comes from the database
// and the rbac object permission can be checked after a fetch.
// The function name must begin with "Get"
//
// Arguments:
// 1. context.Context
// 2. any
// Outputs:
// 1. rbac.Objecter
// 2. error
//
// GetMethods should not result in any database mutations.
// Note: @Emyrk we could look at the sql statements to see if any 'Update', 'Insert',
// or other mutations are being performed with a string search.

func parseGetMethod(method reflect.Method) (*ParsedMethod, bool) {
	// Match the method name.
	if !GetMethodRegex.MatchString(method.Name) {
		return nil, false
	}

	// Requires 2 inputs, 2 outputs.
	if method.Type.NumIn() != 2 || method.Type.NumOut() != 2 {
		return nil, false
	}

	if method.Type.In(0) != contextType {
		return nil, false
	}

	if !method.Type.Out(0).Implements(rbacObjectType) {
		return nil, false
	}

	if method.Type.Out(1) != errorType {
		return nil, false
	}

	return &ParsedMethod{
		Name: method.Name,
		Raw:  method,
		RequiredTypes: []reflect.Type{
			method.Type.In(1),
			method.Type.Out(0),
			errorType,
			contextType,
		},
		TemplateName: "get_method",
		TemplateData: getMethodData{
			FunctionName: method.Name,
			ArgumentType: nameOfType(method.Type.In(1)),
			ReturnType:   nameOfType(method.Type.Out(0)),
		},
	}, true
}

func localType(t reflect.Type) bool {
	return t.PkgPath() == "github.com/coder/coder/coderd/database"
}

func nameOfType(t reflect.Type) string {
	if localType(t) {
		return t.Name()
	}
	return t.String()
}
